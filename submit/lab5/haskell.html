<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="../../assets/styles/article.css" rel="stylesheet" type="text/css" /> 
    <title>CS 471: Lab 5 Haskell</title>
    <link href="haskell/hl-fine_blue.css" rel="stylesheet"/><link href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" 
       rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script>    

  </head>
  <body>
    <nav>
      <ul>
	<li><a href="../../index.html" class="material-icons">house</a></li>
	<li><a href="../../docs/index.html">Docs</a></li>
	<li><a href="../../exercises/index.html">Exercises</a></li>
	<li><a href="../../hws/index.html">Homeworks</a></li>
	<li><a href="../../labs/index.html">Labs</a></li>
	<li><a href="../../misc/index.html">Misc</a></li>
	<li><a href="../../projects/index.html">Projects</a></li>
	<li><a href="../../slides/index.html">Slides</a></li>
	<li><a id="loginAction"></a></li>
      </ul>
    </nav>
    <div class="content">
      <section data-coord="haskell.umt:1:0"><h1 data-coord="haskell.umt:1:0">Lab 5 Haskell</h1><p data-coord="haskell.umt:3:0"><strong data-coord="haskell.umt:3:0">Date</strong>: Apr 22, 2021
</p><p data-coord="haskell.umt:5:0">This document first describes the aims of this lab followed by
exercises which need to be performed.
</p><p data-coord="haskell.umt:8:0">You should perform all exercises using the <samp data-coord="haskell.umt:8:43">hugs</samp> dialect of Prolog
which is installed on remote.cs.  
</p><section data-coord="haskell.umt:11:0"><h2 data-coord="haskell.umt:11:0">Aims</h2><p data-coord="haskell.umt:14:0">The aim of this lab is to introduce you to Haskell.  After completing
this lab, you should have some familiarity with the following topics:
</p><ul data-coord="haskell.umt:17:0"><li data-coord="haskell.umt:17:0"><p data-coord="haskell.umt:17:4">Haskell types and function application.
</p></li><li data-coord="haskell.umt:19:0"><p data-coord="haskell.umt:19:4">Using Haskell's pattern matching to access components of data
structures.
</p></li><li data-coord="haskell.umt:22:0"><p data-coord="haskell.umt:22:4">List comprehensions in Haskell.
</p></li><li data-coord="haskell.umt:24:0"><p data-coord="haskell.umt:24:4">Using map and filter.
</p></li></ul></section><section data-coord="haskell.umt:27:0"><h2 data-coord="haskell.umt:27:0">Exercises</h2><section data-coord="haskell.umt:30:0"><h3 data-coord="haskell.umt:30:0">Starting up</h3><p data-coord="haskell.umt:33:0">Follow the <em data-coord="haskell.umt:33:38"><a href="../working/working.html" data-coord="haskell.umt:33:38">provided directions</a></em> for
starting up this lab in a new git <samp data-coord="haskell.umt:33:98">lab5</samp> branch and a new
<samp data-coord="haskell.umt:33:122">submit/lab5</samp> directory.
</p><p data-coord="haskell.umt:37:0">For this lab, all code should be written in a single file
<samp data-coord="haskell.umt:37:58">lab5-sol.hs</samp> residing in your <samp data-coord="haskell.umt:37:89">submit/lab5</samp> directory. Submit that
file along with a log of your terminal interaction.
</p><p data-coord="haskell.umt:41:0">Note that you can repeately load that file into your Haskell
interpreter using:
</p><pre data-coord="haskell.umt:45:0">Hugs&gt; :l "lab5-sol.hs"
</pre><p data-coord="haskell.umt:48:0">If already loaded, you can reload by simply using:
</p><pre data-coord="haskell.umt:51:0">Hugs&gt; :r 
</pre></section><section data-coord="haskell.umt:54:0"><h3 data-coord="haskell.umt:54:0">Exercise 1: Haskell Types and Function Application</h3><p data-coord="haskell.umt:57:0">All Haskell expressions are statically typed, but usually type
declarations are optional since Haskell infers types automatically.
Within the Hugs REPL, you can use the <samp data-coord="haskell.umt:57:169">:type</samp> directive (abbreviated
<samp data-coord="haskell.umt:57:200">:t</samp>) to check the type of an expression.
</p><p data-coord="haskell.umt:62:0">Add the following to your <samp data-coord="haskell.umt:62:26">lab5-sol.pro</samp> file:
</p><pre><span class="hl slc">-- Exercise 1</span>

<span class="hl slc">-- function which adds two numbers</span>
add n1 n2 <span class="hl opt">=</span> n1 <span class="hl opt">+</span> n2

<span class="hl slc">-- same, but define without using args</span>
plus <span class="hl opt">= (+)</span>

<span class="hl slc">-- function which concats two lists</span>
conc ls1 ls2 <span class="hl opt">=</span> ls1 <span class="hl opt">++</span> ls2</pre><p data-coord="haskell.umt:78:0">Load the <samp data-coord="haskell.umt:78:9">lab5-sol.hs</samp> file into the REPL:
</p><pre data-coord="haskell.umt:82:0">Main&gt; :l "lab5-sol.hs"   
Main&gt; :t add
Main&gt; :t plus
Main&gt; :t conc
</pre><p data-coord="haskell.umt:88:0"><em data-coord="haskell.umt:88:0">expr</em> <samp data-coord="haskell.umt:88:7">::</samp> <em data-coord="haskell.umt:88:12">Type</em> should be read as <em data-coord="haskell.umt:88:37">expr</em> has type <em data-coord="haskell.umt:88:53">Type</em>; The LHS
of the <samp data-coord="haskell.umt:88:76">=&gt;</samp> operator is used to qualify the type variables used on its
RHS.  A type expression like <samp data-coord="haskell.umt:88:169">a -&gt; b</samp> should be read as a function
from <samp data-coord="haskell.umt:88:212">a</samp> to <samp data-coord="haskell.umt:88:219">b</samp>; <samp data-coord="haskell.umt:88:224">-&gt;</samp> is right-associative, i.e.  <samp data-coord="haskell.umt:88:257">a -&gt; b -&gt; c</samp>
associates as <samp data-coord="haskell.umt:88:285">a -&gt; (b -&gt; c)</samp>.
</p><p data-coord="haskell.umt:95:0">Now type in the following to use the above functions:
</p><pre data-coord="haskell.umt:98:0">Main&gt; add 2 3
Main&gt; conc [1] [2, 3]
Main&gt; conc [[1]] [[2, 3]]
Main&gt; conc "hello" "world"
Main&gt; conc ["hello"] ["world"]
Main&gt; conc (conc ["hello"] ["world"]) ["goodbye"]
Main&gt; conc (conc ["hello"] ["world"]) [42]
</pre><ul data-coord="haskell.umt:107:0"><li data-coord="haskell.umt:107:0"><p data-coord="haskell.umt:107:4">What happens if the parentheses are omitted on the second-last line
above?  Why?
</p></li><li data-coord="haskell.umt:110:0"><p data-coord="haskell.umt:110:4">Why does the last line result in an error?
</p></li></ul><p data-coord="haskell.umt:112:0">Add the following function definitions to your <samp data-coord="haskell.umt:112:47">lab5-sol.hs</samp> file:
</p><pre><span class="hl slc">-- partially apply above functions:</span>

add10 <span class="hl opt">=</span> add <span class="hl num">10</span>
plus5 <span class="hl opt">=</span> plus <span class="hl num">5</span>
concHello <span class="hl opt">=</span> conc <span class="hl str">&quot;hello&quot;</span></pre><p data-coord="haskell.umt:123:0">Reload your Haskell REPL with the above file and type directives to look
at the types of these new functions.  Also type expressions which use
these new functions to compute results.
</p></section><section data-coord="haskell.umt:128:0"><h3 data-coord="haskell.umt:128:0">Exercise 2: Haskell Pattern Matching</h3><p data-coord="haskell.umt:131:0">Haskell supports \(n\)-tuples \((a_1, \ldots, a_n)\) when \(a_1, \ldots,
a_n\) can have different types.  A 2-tuple is known as a <strong data-coord="haskell.umt:131:127">pair</strong> and a
3-tuple is a <strong data-coord="haskell.umt:131:153">triple</strong>.  Haskell has built-in functions <samp data-coord="haskell.umt:131:195">fst</samp> and <samp data-coord="haskell.umt:131:205">snd</samp>
to extract the first and second component of a pair:
</p><p data-coord="haskell.umt:136:0">Type the following into your REPL:
</p><pre data-coord="haskell.umt:139:0">Main&gt; let tuple = ("hello", 42) in fst tuple
Main&gt; let tuple = ("hello", 42) in snd tuple
</pre><p data-coord="haskell.umt:143:0">We can define our own versions of <samp data-coord="haskell.umt:143:34">fst</samp> and <samp data-coord="haskell.umt:143:44">snd</samp> in
<samp data-coord="haskell.umt:143:53">lab5-sol.hs</samp>:
</p><pre><span class="hl slc">-- Exercise 2</span>

first <span class="hl opt">(</span>v<span class="hl opt">,</span> _<span class="hl opt">) =</span> v
second <span class="hl opt">(</span>_<span class="hl opt">,</span> v<span class="hl opt">) =</span> v</pre><p data-coord="haskell.umt:154:0">Reload your <samp data-coord="haskell.umt:154:12">lab5-sol.hs</samp> into the REPL and rerun the <samp data-coord="haskell.umt:154:54">fst</samp> and <samp data-coord="haskell.umt:154:64">snd</samp>
examples using <samp data-coord="haskell.umt:154:85">first</samp> and <samp data-coord="haskell.umt:154:97">second</samp>.
</p><ol data-coord="haskell.umt:157:0"><li data-coord="haskell.umt:157:0"><p data-coord="haskell.umt:157:4">If you try something like <samp data-coord="haskell.umt:157:30">first (12, "hello", [])</samp> you will get
an error.  Fix this by defining <samp data-coord="haskell.umt:157:105">fst3</samp> and <samp data-coord="haskell.umt:157:116">snd3</samp> functions which
work on triples.
</p></li><li data-coord="haskell.umt:161:0"><p data-coord="haskell.umt:161:4">Recall that the <samp data-coord="haskell.umt:161:20">:</samp> infix operator is Haskell's equivalent of Scheme's
<samp data-coord="haskell.umt:161:79">cons</samp>.  Use pattern matching to define a function:
</p><pre data-coord="haskell.umt:165:0">    sumFirst2 :: Num a =&gt; [a] -&gt; a
</pre><p data-coord="haskell.umt:168:4">which returns the sum of the first 2 elements of a list of numbers.
</p></li><li data-coord="haskell.umt:170:0"><p data-coord="haskell.umt:170:4">Use pattern matching to define a function
</p><pre data-coord="haskell.umt:173:0">    fnFirst2 :: [a] -&gt; (a -&gt; a -&gt; b) -&gt; (a -&gt; a -&gt; b) -&gt; b
</pre><p data-coord="haskell.umt:176:4">which takes a list <samp data-coord="haskell.umt:176:23">ls</samp> and two functions <samp data-coord="haskell.umt:176:46">f1</samp> and <samp data-coord="haskell.umt:176:55">f2</samp> as
arguments.  If the list has exactly two elements, then the result
of the function should be <samp data-coord="haskell.umt:176:163">f1</samp> applied to the first two elements
of <samp data-coord="haskell.umt:176:209">ls</samp>; otherwise it should be <samp data-coord="haskell.umt:176:238">f2</samp> applied to the first two
elements of <samp data-coord="haskell.umt:176:284">ls</samp>.
</p><pre data-coord="haskell.umt:183:0">    Main&gt; fnFirst2 [3, 4] (+) (*)
    7
    Main&gt; fnFirst2 [3, 4, 5] (+) (*)
    12
</pre></li></ol></section><section data-coord="haskell.umt:189:0"><h3 data-coord="haskell.umt:189:0">Exercise 3: List Comprehensions</h3><p data-coord="haskell.umt:192:0">Add the following to your <samp data-coord="haskell.umt:192:26">lab5-sol.hs</samp> file:
</p><pre><span class="hl slc">-- Exercise 3</span>

cartesianProduct ls1 ls2 <span class="hl opt">=</span>
  <span class="hl opt">[ (</span>x<span class="hl opt">,</span> y<span class="hl opt">)</span> | x <span class="hl opt">&lt;-</span> ls1<span class="hl opt">,</span> y <span class="hl opt">&lt;-</span> ls2 <span class="hl opt">]</span>

cartesianProductIf ls1 ls2 predicate <span class="hl opt">=</span>
  <span class="hl opt">[ (</span>x<span class="hl opt">,</span> y<span class="hl opt">)</span> | x <span class="hl opt">&lt;-</span> ls1<span class="hl opt">,</span> y <span class="hl opt">&lt;-</span> ls2<span class="hl opt">,</span> predicate x y <span class="hl opt">]</span></pre><p data-coord="haskell.umt:205:0">Then run
</p><pre data-coord="haskell.umt:208:0">Main&gt; cartesianProduct [1..4] [2..4]
Main&gt; cartesianProductIf [1..4] [2..4] (&gt;)
</pre><p data-coord="haskell.umt:212:0">and understand how list comprehensions work.
</p><ol data-coord="haskell.umt:214:0"><li data-coord="haskell.umt:214:0"><p data-coord="haskell.umt:214:4">Within the REPL, write a list comprehension which produces the list
of pairs \((x, y)\) such that \(y = 3x^2 + 2x + 1\) for \(x \in 1,
    2, \ldots, 10\).  Recall that <samp data-coord="haskell.umt:214:174">[1..10]</samp> will produce the list <samp data-coord="haskell.umt:214:206">[1,
    2, ..., 10]</samp> and <samp data-coord="haskell.umt:214:232">x^2</samp> will return the square of <samp data-coord="haskell.umt:214:264">x</samp>.
</p><p data-coord="haskell.umt:219:4">The result should be:
</p><pre data-coord="haskell.umt:222:0">    [(1,6),(2,17),(3,34),(4,57),(5,86),(6,121),(7,162),
     (8,209),(9,262),(10,321)]
</pre></li><li data-coord="haskell.umt:226:0"><p data-coord="haskell.umt:226:4">Repeat the previous exercise but return only those pairs whose
second components are a multiple of 3.  <strong data-coord="haskell.umt:226:111">Hint</strong>: The Haskell
function <samp data-coord="haskell.umt:226:144">rem m n</samp> returns the remainder after dividing <samp data-coord="haskell.umt:226:191">m</samp> by
<samp data-coord="haskell.umt:226:202">n</samp>.
</p><p data-coord="haskell.umt:231:4">The result should be:
</p><pre data-coord="haskell.umt:234:0">    [(1,6),(4,57),(7,162),(10,321)]
</pre></li><li data-coord="haskell.umt:238:0"><p data-coord="haskell.umt:238:4">In <samp data-coord="haskell.umt:238:7">lab5-sol.hs</samp>, write a function <samp data-coord="haskell.umt:238:39">oddEvenPairs n</samp> which returns
pairs \((x, y)\) such that \(1 \le x, y \le n\) and \(x\) is odd
while \(y\) is even.  <strong data-coord="haskell.umt:238:161">Hint</strong>: Use Haskell's <samp data-coord="haskell.umt:238:183">odd</samp>, <samp data-coord="haskell.umt:238:190">even</samp> built-in
predicates.
</p><pre data-coord="haskell.umt:244:0">    Main&gt; oddEvenPairs 5
    [(1,2),(1,4),(3,2),(3,4),(5,2),(5,4)]
    Main&gt; oddEvenPairs 7
    [(1,2),(1,4),(1,6),(3,2),(3,4),(3,6),(5,2),(5,4),
     (5,6),(7,2),(7,4),(7,6)]
</pre></li></ol></section><section data-coord="haskell.umt:252:0"><h3 data-coord="haskell.umt:252:0">Exercise 4: Using map and filter</h3><p data-coord="haskell.umt:255:0">List comprehensions can be replaced by using <samp data-coord="haskell.umt:255:45">map</samp> and <samp data-coord="haskell.umt:255:55">filter</samp>.
Look at the type of these functions in the REPL.
</p><ol data-coord="haskell.umt:258:0"><li data-coord="haskell.umt:258:0"><p data-coord="haskell.umt:258:4">Within the REPL, repeat the problem solved earlier using list
comprehensions, but instead base your solution on <samp data-coord="haskell.umt:258:120">map</samp>.
Specifically, write an expression which uses <samp data-coord="haskell.umt:258:176">map</samp> to produce the
list of pairs \((x, y)\) such that \(y = 3x^2 + 2x + 1\) for \(x \in
    1, 2, \ldots, 10\).
</p><p data-coord="haskell.umt:264:4">The result should be:
</p><pre data-coord="haskell.umt:267:0">    [(1,6),(2,17),(3,34),(4,57),(5,86),(6,121),(7,162),
     (8,209),(9,262),(10,321)]
</pre></li><li data-coord="haskell.umt:271:0"><p data-coord="haskell.umt:271:4">Repeat the previous exercise but use <samp data-coord="haskell.umt:271:41">map</samp> and <samp data-coord="haskell.umt:271:51">filter</samp> to return
only those pairs whose second components are a multiple of 3.
</p></li></ol><p data-coord="haskell.umt:274:0">These exercises show that list comprehensions are simpler and more
readable alternatives.</p></section></section></section>
    </div> <!-- #content -->
    <script src="../../assets/scripts/loginAction.js"></script>
  </body>
</html>
